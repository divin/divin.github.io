I"öD<h1 id="introduction">Introduction</h1>

<hr />

<p>Today we are improving our mechanic from <a href="https://divin.github.io/tutorials/godot-tutorial-1/">Tutorial 1</a>. The result will look like this:</p>

<p><img src="/assets/images/posts/post_1/image_0" alt="" class="align-center" /></p>

<p>Looks like similar as before, right? Indeed but we got rid of the ‚ÄúA‚Äù button to switch between draw and drag mode. Also, we got some fancy mouse cursors which indicates when we are able to drag or draw. Thanks to the guys on the <a href="https://www.reddit.com/r/godot/">Godot subreddit</a>, who gave me feedback on my previous tutorial and <a href="https://kicked-in-teeth.itch.io/grab-hand">Kicked-in-Teeth</a> for the Grab Hand package which I used for the mouse cursor. You can download it for free and use it to follow along the tutorial but be aware I flipped the images horizontally.</p>

<p>Again a little disclaimer:</p>

<p><em>This tutorial is more aimed for people with a bit of knowledge in Godot, GDScript and programming in general. I like to use a bit more Object Oriented Programming (OOP) style. Usually I try to define the variables and methods correctly by limiting the data type (for example</em> <code class="language-plaintext highlighter-rouge">var foo : String = "bar"</code> <em>). This is helpful to prevent misuse of variables/methods and makes bug fixing a bit easier in my opinion.</em></p>

<p>Download links for the source code are on my GitHub (or visit the <a href="#download">Download section</a> ‚úåüèº</p>

<h1 id="project-settings">Project Settings</h1>

<hr />

<p>These are the same as for the <a href="https://divin.github.io/tutorials/godot-tutorial-1/#project-settings">previous tutorial</a>. Please have a look there!</p>

<h1 id="creating-the-main-scene">Creating the main scene</h1>

<hr />

<p>We start with something simple this time, the main scene. Just create a <code class="language-plaintext highlighter-rouge">Node2D</code>, name it ‚ÄúMain‚Äù and we are done. This time we don‚Äôt need a script as everything will be handled by the <code class="language-plaintext highlighter-rouge">Paper</code> scene itself. Fancy, right? :)</p>

<h1 id="creating-the-paper-scene">Creating the paper scene</h1>

<hr />

<p>Now to the interesting part, we create a new scene, select as our root node a <code class="language-plaintext highlighter-rouge">TextureRect</code> and name it ‚ÄúPaper‚Äù.</p>

<p><img src="/assets/images/posts/post_1/image_1" alt="" class="align-center" /></p>

<p>After that you might want to set a texture for the <code class="language-plaintext highlighter-rouge">TextureRect</code>. This makes the next step a bit easier</p>

<h2 id="adding-area2d-objects">Adding <code class="language-plaintext highlighter-rouge">Area2D</code> objects</h2>

<p><code class="language-plaintext highlighter-rouge">Area2D</code> objects are great to detect collision. In our case, we use it to have two different areas on our paper that we can distinguish. So, let‚Äôs start.</p>

<p>We add the first <code class="language-plaintext highlighter-rouge">Area2D</code> as a child to our <code class="language-plaintext highlighter-rouge">Paper</code> and name it ‚ÄúDragArea‚Äù. To this area we add a <code class="language-plaintext highlighter-rouge">CollisionShape2D</code> as child this is our collision area. As shape we choose a Rectangle. You should align the <code class="language-plaintext highlighter-rouge">CollisionShape2D</code> to fit the top part of the paper. It should look like this if you‚Äôre done:</p>

<p><img src="/assets/images/posts/post_1/image_2" alt="" class="align-center" /></p>

<p>For the second <code class="language-plaintext highlighter-rouge">Area2D</code> we do basically the same thing except we name it ‚ÄúDrawArea‚Äù and align the <code class="language-plaintext highlighter-rouge">CollisionShape2D</code> to fit the lower part of the paper. When done our paper should look like this:</p>

<p><img src="/assets/images/posts/post_1/image_3" alt="" class="align-center" /></p>

<p>For convenience I left a gap between the two areas. You should avoid overlapping areas.</p>

<p><img src="/assets/images/posts/post_1/image_4" alt="" class="align-center" /></p>

<p>Our scene should look like the picture above. We are done for the moment, so let‚Äôs add a script to our <code class="language-plaintext highlighter-rouge">Paper</code></p>

<p>and call it ‚ÄúPaper‚Äù.</p>

<h2 id="set-variables">Set variables</h2>

<p>As usual we begin with our script by defining some variables which we need later. The <code class="language-plaintext highlighter-rouge">class_name</code> will be ‚ÄúPaper‚Äù. In essence we need the following:</p>

<ul>
  <li>
    <p>a color for our pen, saved in the constant <code class="language-plaintext highlighter-rouge">color_black</code>,</p>
  </li>
  <li>
    <p>some boolean data types which we use to track if we are at the moment <code class="language-plaintext highlighter-rouge">dragging</code> or <code class="language-plaintext highlighter-rouge">drawining</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Vector2</code> to track the <code class="language-plaintext highlighter-rouge">drag_position</code> and the <code class="language-plaintext highlighter-rouge">previous_mouse_position</code></p>
  </li>
  <li>
    <p>an <code class="language-plaintext highlighter-rouge">Node2D</code> which will be used as our pen</p>
  </li>
  <li>
    <p>the name of our areas as strings (<code class="language-plaintext highlighter-rouge">drag_area_name</code> and <code class="language-plaintext highlighter-rouge">draw_area_name</code>)</p>
  </li>
  <li>
    <p>and last but not least some fancy mouse cursors (thanks again to <a href="https://kicked-in-teeth.itch.io/grab-hand">Kicked-in-Teeth</a>)</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class_name Paper
extends TextureRect

# Color
const color_black : Color = Color( 0, 0, 0, 1 ) # Black

# Bools
var dragging : bool = false # dragging mode
var drawing : bool = false # signing mode

# Vector2
var drag_position : Vector2 = Vector2.ZERO # drag vector
var previous_mouse_position : Vector2 = Vector2.ZERO # previouse mouse position vector

onready var pen : Node2D = Node2D.new() # Create an Node2D for the pen when ready

# Name of Areas
var drag_area_name : String = "DragArea" # Name of the Drag Area
var draw_area_name : String = "DrawArea" # Name of the Draw Area

# Mouse Cursor
var standard_mouse = preload("res://assets/Sprites/Mouse_Cursor/hand_01.png") # Standard Coursor

var on_drag_mouse = preload("res://assets/Sprites/Mouse_Cursor/hand_02.png") # Cursor when over Drag Area
var drag_mouse = preload("res://assets/Sprites/Mouse_Cursor/hand_06.png") # Cursor when dragging

var on_draw_mouse = preload("res://assets/Sprites/Mouse_Cursor/hand_08.png") # Cursor when over Draw Area
var draw_mouse = preload("res://assets/Sprites/Mouse_Cursor/hand_03.png") # Cursor when drawing
</code></pre></div></div>

<h2 id="ready-and-process">Ready and process</h2>

<p>In the <code class="language-plaintext highlighter-rouge">_ready</code> method we only call our <code class="language-plaintext highlighter-rouge">make_drawing_possible</code> function which is not really different to the one in the previous tutorial. The <code class="language-plaintext highlighter-rouge">_process</code> method should update our <code class="language-plaintext highlighter-rouge">pen</code> and also our mouse cursor. We get following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func _ready() -&gt; void:
 self.make_drawing_possible()
    
func _process(_delta) -&gt; void:
 self.pen.update()
 self.update_mouse()
</code></pre></div></div>

<h2 id="make-drawing-possible">Make drawing possible</h2>

<p>To make drawing possible we use the same two methods (<code class="language-plaintext highlighter-rouge">make_drawing_possible</code> and <code class="language-plaintext highlighter-rouge">_on_draw</code>) as in my previous tutorial. For more details see <a href="https://divin.github.io/tutorials/godot-tutorial-1/#make-drawing-possible">here</a> and <a href="https://divin.github.io/tutorials/godot-tutorial-1/#draw">here</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func make_drawing_possible() -&gt; void:
 # Create Viewport to render the drawing
 var viewport : Viewport = Viewport.new()
 var rect : Rect2 = self.get_rect()
 viewport.size = rect.size
 viewport.usage = Viewport.USAGE_2D # Render Mode
 #viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Never Clear
 viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Works better!
 viewport.render_target_v_flip = true # OpenGL flips render target we have to flip it again
 viewport.transparent_bg = true # Set Background transparent so we see the drawing
 viewport.add_child(self.pen) # Add the pen as child to viewport
 var error = self.pen.connect("draw", self, "_on_draw") # Connect _on_draw with the draw method from pen
 if error != OK: # If we get an error
  printerr("Couldn't connect Pen. Error Code: ", error)
 self.add_child(viewport) # Add viewport as child

 # Use a sprite to display the result texture
 var rt : Texture = viewport.get_texture()
 var board : TextureRect = TextureRect.new()
 board.set_texture(rt)
 self.add_child(board)

# Draw Method
func _on_draw() -&gt; void:
 var mouse_pos : Vector2 = get_local_mouse_position()
 if self.drawing:
  if Input.is_mouse_button_pressed(BUTTON_LEFT):
   self.pen.draw_line(mouse_pos, self.previous_mouse_position, self.color_black)
 self.previous_mouse_position = mouse_pos # Update previouse position
</code></pre></div></div>

<h2 id="change-mouse-cursor">Change mouse cursor</h2>

<p>To change the mouse cursors we need the method <code class="language-plaintext highlighter-rouge">update_mouse</code>. This method basically just checks if we are hovering over the specific area (<code class="language-plaintext highlighter-rouge">DragArea</code> or <code class="language-plaintext highlighter-rouge">DrawArea</code>) or if we are <code class="language-plaintext highlighter-rouge">dragging</code> or <code class="language-plaintext highlighter-rouge">drawing</code> by calling the mysterious method <code class="language-plaintext highlighter-rouge">is_point_in_area</code>, which we will discuss in a bit.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func update_mouse():
 var mouse_pos : Vector2 = self.get_global_mouse_position() # Get mosue position
 var on_drag : bool = self.is_point_in_area(mouse_pos, drag_area_name) # Check if mouse is in drag area
 var on_draw : bool = self.is_point_in_area(mouse_pos, draw_area_name) # Check if mouse is in draw area
 if on_drag and not Input.is_mouse_button_pressed(BUTTON_LEFT): # If we hover over drag area
  Input.set_custom_mouse_cursor(on_drag_mouse) # Set mouse cursor
 elif self.dragging:
  Input.set_custom_mouse_cursor(drag_mouse) # Set mouse cursor
 elif on_draw and not Input.is_mouse_button_pressed(BUTTON_LEFT): # If we hover over draw area
  Input.set_custom_mouse_cursor(on_draw_mouse) # Set mouse cursor
 elif self.drawing:
  Input.set_custom_mouse_cursor(draw_mouse)
 elif not on_drag and not on_draw: # If not over these areas
  Input.set_custom_mouse_cursor(standard_mouse)
</code></pre></div></div>

<h2 id="are-we-in-the-area">Are we in the area?</h2>

<p>One of the important methods in this script is <code class="language-plaintext highlighter-rouge">is_point_in_area</code>. The issue I encounter is that if you are using <code class="language-plaintext highlighter-rouge">TextureRect</code> and a <code class="language-plaintext highlighter-rouge">Signal</code> from it, like <code class="language-plaintext highlighter-rouge">gui_input</code> (which we will use in the next section), every <code class="language-plaintext highlighter-rouge">InputEvent</code> will be blocked and not passed through to the child objects (at least in Godot 3.2.2). This means, we can‚Äôt just use the <code class="language-plaintext highlighter-rouge">Signal</code> <code class="language-plaintext highlighter-rouge">mouse_entered</code> from the <code class="language-plaintext highlighter-rouge">Area2D</code> object to detect if we are inside the area because all input signals will be blocked by the <code class="language-plaintext highlighter-rouge">TextureRect</code> object. The mouse filter option on the <code class="language-plaintext highlighter-rouge">TextureRect</code> is unfortunately not helpful as we also want to drag the paper.</p>

<p>To solve this issue I ended up checking if a point is inside an area by using the <code class="language-plaintext highlighter-rouge">intersect_point</code> method. See the <a href="https://docs.godotengine.org/en/stable/classes/class_physics2ddirectspacestate.html#method-descriptions">Docs</a> for some more information about this. The important bit was to set <code class="language-plaintext highlighter-rouge">collide_with_areas = true</code>. The method will return an <code class="language-plaintext highlighter-rouge">Array</code> with all colliders we are intersecting. We just loop through these and check if one of the names in equal to the area we are looking for.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Function which checks if a point (Vector2) is inside an Area2D
func is_point_in_area(point : Vector2, area_name : String) -&gt; bool:
 var output : bool = false # Our output, default false
 var space_state : Physics2DDirectSpaceState = get_world_2d().direct_space_state # Get space state of all items
 var result : Array = space_state.intersect_point(point, 32, [], 2147483647, true, true) # Check if points intersect with something
 if result != []: # If we insect with something
  for item in result: # Go through items in the array
   if item["collider"].name == area_name: # Check if collider name equals the name we are looking for
    output = true # set our output to true
 return output
</code></pre></div></div>

<h2 id="dragging">Dragging</h2>

<p>To make dragging possible we use the same method as in our previous tutorial. For more details see <a href="https://divin.github.io/tutorials/godot-tutorial-1/#dragging">here</a>. I have rewritten the code a bit to make it clearer but the idea is the same. The only big difference is that we are just getting the position of the mouse once clicked and give this point to two methods <code class="language-plaintext highlighter-rouge">drag_paper</code> and <code class="language-plaintext highlighter-rouge">draw_paper</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func _on_Paper_gui_input(event):
 # Check if we pressed a mouse button
 if event is InputEventMouseButton:
  # Check if we pressed left mouse button
  if event.button_index == BUTTON_LEFT and event.pressed:
   var point : Vector2 = self.get_global_mouse_position() # Get global mouse position
   # Call methods
   self.drag_paper(point)
   self.draw_paper(point)
  else:
   # Else set dragging and drawing false
   self.dragging = false
   self.drawing = false
 # Check if we moved the mouse while we drag the paper
 if event is InputEventMouseMotion and drag_position != Vector2.ZERO and self.dragging:
  # Set new position
  self.rect_global_position = self.get_global_mouse_position() - self.drag_position
</code></pre></div></div>

<h2 id="drag--draw">Drag &amp; Draw</h2>

<p>In essence these methods only check if we are inside the areas and set the boolean data types <code class="language-plaintext highlighter-rouge">dragging</code> and <code class="language-plaintext highlighter-rouge">drawing</code>. The method <code class="language-plaintext highlighter-rouge">drag_paper</code> does also some fancy stuff by updating the <code class="language-plaintext highlighter-rouge">drag_position</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Drag Method which checks if we are dragging the paper
func drag_paper(point : Vector2) -&gt; void:
 self.dragging = is_point_in_area(point, drag_area_name) # Check if mouse is in drag area
 if self.dragging:
  self.drag_position = self.get_global_mouse_position() - self.rect_global_position # Update drag position
 else:
  self.drag_position = Vector2.ZERO # Set drag position to zero vector

# Draw Method which checks if we are drawing on the paper 
func draw_paper(point : Vector2) -&gt; void:
 self.drawing = is_point_in_area(point, draw_area_name) # Check if mouse is in draw area
</code></pre></div></div>

<h1 id="conclusion">Conclusion</h1>

<hr />

<p>That‚Äôs it! If you followed this tutorial correctly, you should be able to drag a paper and also draw on it. Based on this you can expand this mechanic for all kinds of application. I hope you enjoyed it!</p>

<p>I‚Äôm making a little game based on this mechanic, I‚Äôll post other tutorials where we expand this idea a bit further. So stay tuned! :)</p>

<h1 id="download">Download</h1>

<hr />

<p>You can find the the source code for this tutorial and all previous and upcoming tutorials <a href="https://github.com/divin/Godot-Tutorials">here</a>.</p>

:ET