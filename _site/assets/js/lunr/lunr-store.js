var store = [{
        "title": "Tutorial 1: Drawable & Draggable Paper In Godot",
        "excerpt":"Introduction     In this tutorial I‚Äôll show you how to make a drawable and draggable paper in Godot. The result will look like this:      This tutorial is more aimed for people with a bit of knowledge in Godot and GDScript. I like to use a bit more Object Oriented Programming (OOP) style and usually try to define the variables and methods correctly by limiting the data type (for example var foo : String = \"bar\"). This is helpful to prevent misuse of variables/methods and make bug fixing a bit easier in my opinion.   Download links for the source code are on my GitHub (or visit the Download section ‚úåüèº   Project settings     The only changes I did to the project settings were made under Display/Window:   Width = 320 Height = 180 ... Test Width = 1280 Test Height = 720 ... Mode = 2d Aspect = expand   Creating the paper scene     We will start with the interesting part, the paper itself. We make a new scene, use a TextureRect as our root node and name it ‚ÄúPaper‚Äù. I didn‚Äôt changed any settings in the inspector. Depending on your aim you want to add now a texture to the TextureRect or later in the Main scene.   Set variables   Next, we attach a script to it. I usually like to give the script a class_name, the name of the script itself (in our case Paper). Let‚Äôs define some variables:   class_name Paper extends TextureRect  # Bool to check if pen is selected var pen_selected : bool  # Drawing color of the pen const color : Color = Color( 0, 0, 0, 1 ) # Black  # Saves the Position if the Paper is being dragged var drag_position : Vector2 = Vector2.ZERO  # Save the previouse Mouse position var previous_mouse_position : Vector2 = Vector2.ZERO  # Create an Node2D for the pen when ready onready var pen : Node2D = Node2D.new()   Most of them are self-explanatory (or explained by the comments), the pen variable, which is an Node2D, is used to create our ‚Äúpen‚Äù. We will call the draw method from this Node to do the drawing.   Setter function   We also need a function to set our variable pen_selected from outside the script:   # Setter function for pen_selected func set_pen_selected(is_selected : bool) -&gt; void:   self.pen_selected = is_selected   Make drawing possible   Now is time to make the drawing possible   func make_drawing_possible() -&gt; void:    # Create Viewport to render the drawing   var viewport = Viewport.new()   var rect = self.get_rect() # Get the size of the TextureRect   viewport.size = rect.size # Set size of viewport to the size of TextureRect   viewport.usage = Viewport.USAGE_2D # Render Mode   viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Works better than CLEAR_MODE_NEVER   viewport.render_target_v_flip = true # OpenGL flips render target so we have to flip it again   viewport.transparent_bg = true # Set Background transparent so we see the drawing   viewport.add_child(self.pen) # Add the pen as child to the Viewport    self.pen.connect(\"draw\", self, \"_on_draw\") # Connect _on_draw with the draw method from pen   self.add_child(viewport) # Add viewport as child      # Use a sprite to display the result texture   var rt = viewport.get_texture() # Which is transparent   var board = TextureRect.new() # Make a canvas (also TextureRect)   board.set_texture(rt) # Set texture   self.add_child(board) # Add canvas   I‚Äôve commented the code as good as possible to get an understanding what is happening. Credit goes to a user called ‚ÄúZylann‚Äù from this post. I had to change some bits to suit my needs.   Basically we create an new Viewport to render the drawing (with the same size as our Paper) and add our pen as child. We connect the _on_draw method (which we will define in a bit) to the draw method of the pen. After that we add the Viewport as child to the Paper, create another TextureRect which suits us as canvas.   Get ready and process   The next step is simple, we call our monstrosity of function make_drawing_possible in _ready and update the pen in _process.   func _ready() -&gt; void:   self.make_signature_possible()  func _process(_delta) -&gt; void:   self.pen.update()   Draw   Now it‚Äôs time to define _on_draw:   func _on_draw() -&gt; void:   if self.pen_selected:     var mouse_pos = self.get_local_mouse_position() # Get local mouse position      if Input.is_mouse_button_pressed(BUTTON_LEFT):       self.pen.draw_line(mouse_pos, self.previous_mouse_position, self.color) # Finally draw something     self.previous_mouse_position = mouse_pos # Update previous mouse position   If pen_selected == true we get the mouse position and if we also press the left mouse button we start drawing. Before we return we update the previous_mouse_position.   Dragging   Now to make the paper also draggable we select Paper (the TextureRect) in the scene view and click at the Node tab (usually next to the Inspector tab). Here we want to connect the gui_input(event : InputEvent) with our script. A function should be automatically generated in the Paper.gd once connected. The name will be differ depending how you named the TextureRect.   func _on_Paper_gui_input(event : InputEvent) -&gt; void:    if not self.pen_selected:     if event is InputEventMouseButton:       if event.pressed:         self.drag_position = self.get_global_mouse_position() - self.rect_global_position       else:         self.drag_position = Vector2.ZERO     if event is InputEventMouseMotion and drag_position != Vector2.ZERO:       self.rect_global_position = self.get_global_mouse_position() - self.drag_position   If we didn‚Äôt select the pen and the InputEvent recognized an event of type InputEventMouseButton (we clicked a mouse button) and is pressed we want to update the drag_position. Otherwise we want to set the drag_position to a zero vector. If there is an event type InputEventMouseMotion (we moved the mouse) and the drag_position is not a zero vector we want to update the position of the TextureRect.   Creating the main scene     Now we getting closer to the finish. We make now our Main scene. Simply by creating an new scene, choose a basic Node2D as root node and name it ‚ÄúMain‚Äù. Before we start programming we drag and drop the Paper scene inside our Main scene.   Set variables   Similar to Paper scene we create some variables. A variable paper which refers to the just added Paper scene and pen_selected which is the same as we used in Paper.gd.   class_name Main extends Node2D  # Grab the Paper when ready onready var paper : Paper = $Paper  # Bool to store if pen is selected var pen_selected : bool = false   Get input   We now want to be able to switch between dragging and drawing. This is done by a simple key press (in this case ‚ÄúA‚Äù).   func _input(event) -&gt; void:    # Bool to check if the button is just pressed (not needed if you assigned a action key)   var just_pressed : bool = event.is_pressed() and not event.is_echo()    # Check if the \"A\" button was just pressed   if Input.is_key_pressed(KEY_A) and just_pressed:     self.select_pen()   If the ‚ÄúA‚Äù key is just pressed, we want to call a method select_pen which communicates between the Main.gd and Paper.gd.   Select the pen   The last step is to set pen_selected in Paper.gd:   func select_pen() -&gt; void:   # Function which selectes the pen    # Negate pen_selected   self.pen_selected = not self.pen_selected    # Set pen_selected from the paper   paper.set_pen_selected(self.pen_selected)   Now you should be able to draw on the paper :)   Conclusion     If you followed this tutorial correctly, you should be able to drag a paper and also draw on it. Based on this you can expand this mechanic for all kinds of application. I hope you enjoyed it!   I‚Äôm making a little game based on this mechanic, I‚Äôll post other tutorials where we expand this idea a bit further. So stay tuned! :)   Download     You can find the the source code for this tutorial and all upcoming tutorials here.   ","categories": ["Tutorials"],
        "tags": ["Godot","Tutorial","Taikun"],
        "url": "http://localhost:4000/tutorials/tutorial-1/",
        "teaser": null
      },{
        "title": "Tutorial 2: Drawable & Draggable Paper In Godot (Improved)",
        "excerpt":"Introduction     Today we are improving our mechanic from Tutorial 1. The result will look like this:      Looks like similar as before, right? Indeed but we got rid of the ‚ÄúA‚Äù button to switch between draw and drag mode. Also, we got some fancy mouse cursors which indicates when we are able to drag or draw. Thanks to the guys on the Godot subreddit, who gave me feedback on my previous tutorial and Kicked-in-Teeth for the Grab Hand package which I used for the mouse cursor. You can download it for free and use it to follow along the tutorial but be aware I flipped the images horizontally.   Again a little disclaimer:   This tutorial is more aimed for people with a bit of knowledge in Godot, GDScript and programming in general. I like to use a bit more Object Oriented Programming (OOP) style. Usually I try to define the variables and methods correctly by limiting the data type (for example var foo : String = \"bar\" ). This is helpful to prevent misuse of variables/methods and makes bug fixing a bit easier in my opinion.   Download links for the source code are on my GitHub (or visit the Download section ‚úåüèº   Project Settings     These are the same as for the previous tutorial. Please have a look there!   Creating the main scene     We start with something simple this time, the main scene. Just create a Node2D, name it ‚ÄúMain‚Äù and we are done. This time we don‚Äôt need a script as everything will be handled by the Paper scene itself. Fancy, right? :)   Creating the paper scene     Now to the interesting part, we create a new scene, select as our root node a TextureRect and name it ‚ÄúPaper‚Äù.      After that you might want to set a texture for the TextureRect. This makes the next step a bit easier   Adding Area2D objects   Area2D objects are great to detect collision. In our case, we use it to have two different areas on our paper that we can distinguish. So, let‚Äôs start.   We add the first Area2D as a child to our Paper and name it ‚ÄúDragArea‚Äù. To this area we add a CollisionShape2D as child this is our collision area. As shape we choose a Rectangle. You should align the CollisionShape2D to fit the top part of the paper. It should look like this if you‚Äôre done:      For the second Area2D we do basically the same thing except we name it ‚ÄúDrawArea‚Äù and align the CollisionShape2D to fit the lower part of the paper. When done our paper should look like this:      For convenience I left a gap between the two areas. You should avoid overlapping areas.      Our scene should look like the picture above. We are done for the moment, so let‚Äôs add a script to our Paper   and call it ‚ÄúPaper‚Äù.   Set variables   As usual we begin with our script by defining some variables which we need later. The class_name will be ‚ÄúPaper‚Äù. In essence we need the following:           a color for our pen, saved in the constant color_black,            some boolean data types which we use to track if we are at the moment dragging or drawining            Vector2 to track the drag_position and the previous_mouse_position            an Node2D which will be used as our pen            the name of our areas as strings (drag_area_name and draw_area_name)            and last but not least some fancy mouse cursors (thanks again to Kicked-in-Teeth)       class_name Paper extends TextureRect  # Color const color_black : Color = Color( 0, 0, 0, 1 ) # Black  # Bools var dragging : bool = false # dragging mode var drawing : bool = false # signing mode  # Vector2 var drag_position : Vector2 = Vector2.ZERO # drag vector var previous_mouse_position : Vector2 = Vector2.ZERO # previouse mouse position vector  onready var pen : Node2D = Node2D.new() # Create an Node2D for the pen when ready  # Name of Areas var drag_area_name : String = \"DragArea\" # Name of the Drag Area var draw_area_name : String = \"DrawArea\" # Name of the Draw Area  # Mouse Cursor var standard_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_01.png\") # Standard Coursor  var on_drag_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_02.png\") # Cursor when over Drag Area var drag_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_06.png\") # Cursor when dragging  var on_draw_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_08.png\") # Cursor when over Draw Area var draw_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_03.png\") # Cursor when drawing   Ready and process   In the _ready method we only call our make_drawing_possible function which is not really different to the one in the previous tutorial. The _process method should update our pen and also our mouse cursor. We get following:   func _ready() -&gt; void:  self.make_drawing_possible()      func _process(_delta) -&gt; void:  self.pen.update()  self.update_mouse()   Make drawing possible   To make drawing possible we use the same two methods (make_drawing_possible and _on_draw) as in my previous tutorial. For more details see here and here.   func make_drawing_possible() -&gt; void:  # Create Viewport to render the drawing  var viewport : Viewport = Viewport.new()  var rect : Rect2 = self.get_rect()  viewport.size = rect.size  viewport.usage = Viewport.USAGE_2D # Render Mode  #viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Never Clear  viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Works better!  viewport.render_target_v_flip = true # OpenGL flips render target we have to flip it again  viewport.transparent_bg = true # Set Background transparent so we see the drawing  viewport.add_child(self.pen) # Add the pen as child to viewport  var error = self.pen.connect(\"draw\", self, \"_on_draw\") # Connect _on_draw with the draw method from pen  if error != OK: # If we get an error   printerr(\"Couldn't connect Pen. Error Code: \", error)  self.add_child(viewport) # Add viewport as child   # Use a sprite to display the result texture  var rt : Texture = viewport.get_texture()  var board : TextureRect = TextureRect.new()  board.set_texture(rt)  self.add_child(board)  # Draw Method func _on_draw() -&gt; void:  var mouse_pos : Vector2 = get_local_mouse_position()  if self.drawing:   if Input.is_mouse_button_pressed(BUTTON_LEFT):    self.pen.draw_line(mouse_pos, self.previous_mouse_position, self.color_black)  self.previous_mouse_position = mouse_pos # Update previouse position   Change mouse cursor   To change the mouse cursors we need the method update_mouse. This method basically just checks if we are hovering over the specific area (DragArea or DrawArea) or if we are dragging or drawing by calling the mysterious method is_point_in_area, which we will discuss in a bit.   func update_mouse():  var mouse_pos : Vector2 = self.get_global_mouse_position() # Get mosue position  var on_drag : bool = self.is_point_in_area(mouse_pos, drag_area_name) # Check if mouse is in drag area  var on_draw : bool = self.is_point_in_area(mouse_pos, draw_area_name) # Check if mouse is in draw area  if on_drag and not Input.is_mouse_button_pressed(BUTTON_LEFT): # If we hover over drag area   Input.set_custom_mouse_cursor(on_drag_mouse) # Set mouse cursor  elif self.dragging:   Input.set_custom_mouse_cursor(drag_mouse) # Set mouse cursor  elif on_draw and not Input.is_mouse_button_pressed(BUTTON_LEFT): # If we hover over draw area   Input.set_custom_mouse_cursor(on_draw_mouse) # Set mouse cursor  elif self.drawing:   Input.set_custom_mouse_cursor(draw_mouse)  elif not on_drag and not on_draw: # If not over these areas   Input.set_custom_mouse_cursor(standard_mouse)   Are we in the area?   One of the important methods in this script is is_point_in_area. The issue I encounter is that if you are using TextureRect and a Signal from it, like gui_input (which we will use in the next section), every InputEvent will be blocked and not passed through to the child objects (at least in Godot 3.2.2). This means, we can‚Äôt just use the Signal mouse_entered from the Area2D object to detect if we are inside the area because all input signals will be blocked by the TextureRect object. The mouse filter option on the TextureRect is unfortunately not helpful as we also want to drag the paper.   To solve this issue I ended up checking if a point is inside an area by using the intersect_point method. See the Docs for some more information about this. The important bit was to set collide_with_areas = true. The method will return an Array with all colliders we are intersecting. We just loop through these and check if one of the names in equal to the area we are looking for.   # Function which checks if a point (Vector2) is inside an Area2D func is_point_in_area(point : Vector2, area_name : String) -&gt; bool:  var output : bool = false # Our output, default false  var space_state : Physics2DDirectSpaceState = get_world_2d().direct_space_state # Get space state of all items  var result : Array = space_state.intersect_point(point, 32, [], 2147483647, true, true) # Check if points intersect with something  if result != []: # If we insect with something   for item in result: # Go through items in the array    if item[\"collider\"].name == area_name: # Check if collider name equals the name we are looking for     output = true # set our output to true  return output   Dragging   To make dragging possible we use the same method as in our previous tutorial. For more details see here. I have rewritten the code a bit to make it clearer but the idea is the same. The only big difference is that we are just getting the position of the mouse once clicked and give this point to two methods drag_paper and draw_paper.   func _on_Paper_gui_input(event):  # Check if we pressed a mouse button  if event is InputEventMouseButton:   # Check if we pressed left mouse button   if event.button_index == BUTTON_LEFT and event.pressed:    var point : Vector2 = self.get_global_mouse_position() # Get global mouse position    # Call methods    self.drag_paper(point)    self.draw_paper(point)   else:    # Else set dragging and drawing false    self.dragging = false    self.drawing = false  # Check if we moved the mouse while we drag the paper  if event is InputEventMouseMotion and drag_position != Vector2.ZERO and self.dragging:   # Set new position   self.rect_global_position = self.get_global_mouse_position() - self.drag_position   Drag &amp; Draw   In essence these methods only check if we are inside the areas and set the boolean data types dragging and drawing. The method drag_paper does also some fancy stuff by updating the drag_position.   # Drag Method which checks if we are dragging the paper func drag_paper(point : Vector2) -&gt; void:  self.dragging = is_point_in_area(point, drag_area_name) # Check if mouse is in drag area  if self.dragging:   self.drag_position = self.get_global_mouse_position() - self.rect_global_position # Update drag position  else:   self.drag_position = Vector2.ZERO # Set drag position to zero vector  # Draw Method which checks if we are drawing on the paper  func draw_paper(point : Vector2) -&gt; void:  self.drawing = is_point_in_area(point, draw_area_name) # Check if mouse is in draw area   Conclusion     That‚Äôs it! If you followed this tutorial correctly, you should be able to drag a paper and also draw on it. Based on this you can expand this mechanic for all kinds of application. I hope you enjoyed it!   I‚Äôm making a little game based on this mechanic, I‚Äôll post other tutorials where we expand this idea a bit further. So stay tuned! :)   Download     You can find the the source code for this tutorial and all previous and upcoming tutorials here.   ","categories": ["Tutorials"],
        "tags": ["Godot","Tutorial","Taikun"],
        "url": "http://localhost:4000/tutorials/tutorial-2/",
        "teaser": null
      }]
