var store = [{
        "title": "Tutorial 1: Drawable & Draggable Paper In Godot",
        "excerpt":"Introduction   In this tutorial I’ll show you how to make a drawable and draggable paper in Godot. The result will look like this:      This tutorial is more aimed for people with a bit of knowledge in Godot and GDScript. I like to use a bit more Object Oriented Programming (OOP) style and usually try to define the variables and methods correctly by limiting the data type (for example var foo : String = \"bar\"). This is helpful to prevent misuse of variables/methods and make bug fixing a bit easier in my opinion.   Download links for the source code are on my GitHub (or visit the Download section) :)   Project settings   The only changes I did to the project settings were made under Display/Window:   Width = 320 Height = 180 ... Test Width = 1280 Test Height = 720 ... Mode = 2d Aspect = expand   Creating the paper scene   We will start with the interesting part, the paper itself. We make a new scene, use a TextureRect as our root node and name it “Paper”. I didn’t changed any settings in the inspector. Depending on your aim you want to add now a texture to the TextureRect or later in the Main scene.   Set variables   Next, we attach a script to it. I usually like to give the script a class_name, the name of the script itself (in our case Paper). Let’s define some variables:   class_name Paper extends TextureRect  # Bool to check if pen is selected var pen_selected : bool  # Drawing color of the pen const color : Color = Color( 0, 0, 0, 1 ) # Black  # Saves the Position if the Paper is being dragged var drag_position : Vector2 = Vector2.ZERO  # Save the previouse Mouse position var previous_mouse_position : Vector2 = Vector2.ZERO  # Create an Node2D for the pen when ready onready var pen : Node2D = Node2D.new()   Most of them are self-explanatory (or explained by the comments), the pen variable, which is an Node2D, is used to create our “pen”. We will call the draw method from this Node to do the drawing.   Setter function   We also need a function to set our variable pen_selected from outside the script:   # Setter function for pen_selected func set_pen_selected(is_selected : bool) -&gt; void:   self.pen_selected = is_selected   Make drawing possible   Now is time to make the drawing possible   func make_drawing_possible() -&gt; void:    # Create Viewport to render the drawing   var viewport = Viewport.new()   var rect = self.get_rect() # Get the size of the TextureRect   viewport.size = rect.size # Set size of viewport to the size of TextureRect   viewport.usage = Viewport.USAGE_2D # Render Mode   viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Works better than CLEAR_MODE_NEVER   viewport.render_target_v_flip = true # OpenGL flips render target so we have to flip it again   viewport.transparent_bg = true # Set Background transparent so we see the drawing   viewport.add_child(self.pen) # Add the pen as child to the Viewport    self.pen.connect(\"draw\", self, \"_on_draw\") # Connect _on_draw with the draw method from pen   self.add_child(viewport) # Add viewport as child      # Use a sprite to display the result texture   var rt = viewport.get_texture() # Which is transparent   var board = TextureRect.new() # Make a canvas (also TextureRect)   board.set_texture(rt) # Set texture   self.add_child(board) # Add canvas   I’ve commented the code as good as possible to get an understanding what is happening. Credit goes to a user called “Zylann” from this post. I had to change some bits to suit my needs.   Basically we create an new Viewport to render the drawing (with the same size as our Paper) and add our pen as child. We connect the _on_draw method (which we will define in a bit) to the draw method of the pen. After that we add the Viewport as child to the Paper, create another TextureRect which suits us as canvas.   Get ready and process   The next step is simple, we call our monstrosity of function make_drawing_possible in _ready and update the pen in _process.   func _ready() -&gt; void:   self.make_signature_possible()  func _process(_delta) -&gt; void:   self.pen.update()   Draw   Now it’s time to define _on_draw:   func _on_draw() -&gt; void:   if self.pen_selected:     var mouse_pos = self.get_local_mouse_position() # Get local mouse position      if Input.is_mouse_button_pressed(BUTTON_LEFT):       self.pen.draw_line(mouse_pos, self.previous_mouse_position, self.color) # Finally draw something     self.previous_mouse_position = mouse_pos # Update previous mouse position   If pen_selected == true we get the mouse position and if we also press the left mouse button we start drawing. Before we return we update the previous_mouse_position.   Dragging   Now to make the paper also draggable we select Paper (the TextureRect) in the scene view and click at the Node tab (usually next to the Inspector tab). Here we want to connect the gui_input(event : InputEvent) with our script. A function should be automatically generated in the Paper.gd once connected. The name will be differ depending how you named the TextureRect.   func _on_Paper_gui_input(event : InputEvent) -&gt; void:    if not self.pen_selected:     if event is InputEventMouseButton:       if event.pressed:         self.drag_position = self.get_global_mouse_position() - self.rect_global_position       else:         self.drag_position = Vector2.ZERO     if event is InputEventMouseMotion and drag_position != Vector2.ZERO:       self.rect_global_position = self.get_global_mouse_position() - self.drag_position   If we didn’t select the pen and the InputEvent recognized an event of type InputEventMouseButton (we clicked a mouse button) and is pressed we want to update the drag_position. Otherwise we want to set the drag_position to a zero vector. If there is an event type InputEventMouseMotion (we moved the mouse) and the drag_position is not a zero vector we want to update the position of the TextureRect.   Creating the main scene   Now we getting closer to the finish. We make now our Main scene. Simply by creating an new scene, choose a basic Node2D as root node and name it “Main”. Before we start programming we drag and drop the Paper scene inside our Main scene.   Set variables   Similar to Paper scene we create some variables. A variable paper which refers to the just added Paper scene and pen_selected which is the same as we used in Paper.gd.   class_name Main extends Node2D  # Grab the Paper when ready onready var paper : Paper = $Paper  # Bool to store if pen is selected var pen_selected : bool = false   Get input   We now want to be able to switch between dragging and drawing. This is done by a simple key press (in this case “A”).   func _input(event) -&gt; void:    # Bool to check if the button is just pressed (not needed if you assigned a action key)   var just_pressed : bool = event.is_pressed() and not event.is_echo()    # Check if the \"A\" button was just pressed   if Input.is_key_pressed(KEY_A) and just_pressed:     self.select_pen()   If the “A” key is just pressed, we want to call a method select_pen which communicates between the Main.gd and Paper.gd.   Select the pen   The last step is to set pen_selected in Paper.gd:   func select_pen() -&gt; void:   # Function which selectes the pen    # Negate pen_selected   self.pen_selected = not self.pen_selected    # Set pen_selected from the paper   paper.set_pen_selected(self.pen_selected)   Now you should be able to draw on the paper :)   Conclusion   If you followed this tutorial correctly, you should be able to drag a paper and also draw on it. Based on this you can expand this mechanic for all kinds of application. I hope you enjoyed it!   I’m making a little game based on this mechanic, I’ll post other tutorials where we expand this idea a bit further. So stay tuned! :)   Download    You can find the the source code for this tutorial and all upcoming tutorials here.  ","categories": ["Tutorials"],
        "tags": ["Godot","Tutorial","Taikun"],
        "url": "http://localhost:4000/tutorials/godot-tutorial-1/",
        "teaser": null
      },{
        "title": "Tutorial 2: Drawable & Draggable Paper In Godot (Improved)",
        "excerpt":"Introduction   Today we are improving our mechanic from Tutorial 1. The result will look like this:      Looks like similar as before, right? Indeed but we got rid of the “A” button to switch between draw and drag mode. Also, we got some fancy mouse cursors which indicates when we are able to drag or draw. Thanks to the guys on the Godot subreddit, who gave me feedback on my previous tutorial and Kicked-in-Teeth for the Grab Hand package which I used for the mouse cursor.   Again a little disclaimer:   This tutorial is more aimed for people with a bit of knowledge in Godot, GDScript and programming in general. I like to use a bit more Object Oriented Programming (OOP) style. Usually I try to define the variables and methods correctly by limiting the data type (for example var foo : String = \"bar\" ). This is helpful to prevent misuse of variables/methods and makes bug fixing a bit easier in my opinion.   Download links for the source code are on my GitHub (or visit the Download section) :)   Project Settings   These are the same as for the previous tutorial. Please have a look there!   Creating the main scene   We start with something simple this time, the main scene. Just create a Node2D, name it “Main” and we are done.  This time we don’t need a script as everything will be handled by the Paper scene itself. Fancy, right? :)   Creating the paper scene   Now to the interesting part, we create a new scene, select as our root node a TextureRect and name it “Paper”.      After that we set the texture for our TextureRect. Next we want to create two Area2D objects.   Adding Area2D objects   Area2D objects are great to detect collision, we use it to have two different areas on our paper we can distinguish. So, let’s start.   We add the first Area2D and name it “DragArea”. To this area we add a CollisionShape2D as child this is our collision area. As shape we choose a Rectangle. You should align the CollisionShape2D to fit the top part of the paper. It should look like this if you’re done:      For the second Area2D we do basically the same thing except we name it “DrawArea” and align the CollisionShape2D to fit the lower part of the paper.  When done our paper should look like this:      For convenience I left a gap between the two areas. You should avoid overlapping areas.    Our scene should look like the picture on the left. We are done for the moment, so let’s add a script to our Paper and also call it “Paper”.   Set variables   As usual we begin with our script by defining some variables we need later. The class_name will be “Paper”. In essence we need the following:      a color for our pen, saved in the constant color_black,   some boolean data types which we use to track if we are at the moment dragging or drawing  (dragging and drawing)   Vector2 to track the drag and previous mouse position (drag_position and previous_mouse_position)   an Node2D which will be used as our pen   the name of our areas as strings   and last but not least some fancy mouse cursors (thanks to Kicked-in-Teeth)   class_name Paper extends TextureRect  # Color const color_black : Color = Color( 0, 0, 0, 1 ) # Black  # Bools var dragging : bool = false # dragging mode var drawing : bool = false # signing mode  # Vector2 var drag_position : Vector2 = Vector2.ZERO # drag vector var previous_mouse_position : Vector2 = Vector2.ZERO # previouse mouse position vector  onready var pen : Node2D = Node2D.new() # Create an Node2D for the pen when ready  # Name of Areas var drag_area_name : String = \"DragArea\" # Name of the Drag Area var draw_area_name : String = \"DrawArea\" # Name of the Draw Area  # Mouse Cursor var standard_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_01.png\") # Standard Coursor  var on_drag_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_02.png\") # Cursor when over Drag Area var drag_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_06.png\") # Cursor when dragging  var on_draw_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_08.png\") # Cursor when over Draw Area var draw_mouse = preload(\"res://assets/Sprites/Mouse_Cursor/hand_03.png\") # Cursor when drawing   Ready and process   In the _ready method we only call our make_drawing_possible function which is not really different to the one in the previous tutorial.  The _process method should update our pen and also our mouse cursor. We get following:   func _ready() -&gt; void: \tself.make_drawing_possible() \t func _process(_delta) -&gt; void: \tself.pen.update() \tself.update_mouse()   Make drawing possible   To make drawing possible we use the same method as in my previous tutorial. For more details see here.   func make_drawing_possible() -&gt; void: \t# Create Viewport to render the drawing \tvar viewport : Viewport = Viewport.new() \tvar rect : Rect2 = self.get_rect() \tviewport.size = rect.size \tviewport.usage = Viewport.USAGE_2D # Render Mode \t#viewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Never Clear \tviewport.render_target_clear_mode = Viewport.CLEAR_MODE_ONLY_NEXT_FRAME # Works better! \tviewport.render_target_v_flip = true # OpenGL flips render target we have to flip it again \tviewport.transparent_bg = true # Set Background transparent so we see the drawing \tviewport.add_child(self.pen) # Add the pen as child to viewport \tvar error = self.pen.connect(\"draw\", self, \"_on_draw\") # Connect _on_draw with the draw method from pen \tif error != OK: # If we get an error \t\tprinterr(\"Couldn't connect Pen. Error Code: \", error) \tself.add_child(viewport) # Add viewport as child \t \t# Use a sprite to display the result texture \tvar rt : Texture = viewport.get_texture() \tvar board : TextureRect = TextureRect.new() \tboard.set_texture(rt) \tself.add_child(board)  # Draw Method func _on_draw() -&gt; void: \tvar mouse_pos : Vector2 = get_local_mouse_position() \tif self.drawing: \t\tif Input.is_mouse_button_pressed(BUTTON_LEFT): \t\t\tInput.set_custom_mouse_cursor(draw_mouse) # Change mouse cursor \t\t\tself.pen.draw_line(mouse_pos, self.previous_mouse_position, self.color_black) \tself.previous_mouse_position = mouse_pos # Update previouse position   Change mouse cursor   To change the mouse cursors we need the method update_mouse. This method basically just checks if we are hovering over the specific area (DragArea or DrawArea) by calling the mysterious method is_point_in_area, which we will discuss in a bit.   # Updat Mouse Method func update_mouse(): \tvar mouse_pos : Vector2 = self.get_global_mouse_position() # Get mosue position \tvar on_drag : bool = self.is_point_in_area(mouse_pos, drag_area_name) # Check if mouse is in drag area \tvar on_draw : bool = self.is_point_in_area(mouse_pos, draw_area_name) # Check if mouse is in draw area \tif on_drag and not Input.is_mouse_button_pressed(BUTTON_LEFT): # If we hover over drag area \t\tInput.set_custom_mouse_cursor(on_drag_mouse) # Set mouse cursor \telif on_draw and not Input.is_mouse_button_pressed(BUTTON_LEFT): # If we hover over draw area \t\tInput.set_custom_mouse_cursor(on_draw_mouse) # Set mouse cursor \telif not on_drag and not on_draw: # If not over these areas \t\tInput.set_custom_mouse_cursor(standard_mouse)   Are we in the area?   One of the important methods in this script is is_point_in_area. The issue I encounter is that if you are using TextureRect and a Signal from it, like gui_input (which we will use in the next section), all InputEvents we be blocked and not passed through to the child objects (at least in Godot 3.2.2). This means, we can’t just use the Signal mouse_entered from the Area2D object to detect if we are inside the area because all input signals will be blocked by the TextureRect object. The mouse filter option on the TextureRect is unfortunately not helpful as we also want to drag the paper.   To solve this issue I ended up checking if a point is inside an area by using the intersect_point method. See the Docs for some more information about this. The important bit was to set collide_with_areas = true. The method will return an Array with all colliders we are intersecting. We just loop through these and check if one of the names in equal to the area we are looking for.   # Function which checks if a point (Vector2) is inside an Area2D func is_point_in_area(point : Vector2, area_name : String) -&gt; bool: \tvar output : bool = false # Our output, default false \tvar space_state : Physics2DDirectSpaceState = get_world_2d().direct_space_state # Get space state of all items \tvar result : Array = space_state.intersect_point(point, 32, [], 2147483647, true, true) # Check if points intersect with something \tif result != []: # If we insect with something \t\tfor item in result: # Go through items in the array \t\t\tif item[\"collider\"].name == area_name: # Check if collider name equals the name we are looking for \t\t\t\toutput = true # set our output to true \treturn output   Dragging   To make dragging possible we use the same method as in our previous tutorial. For more details see here. I have rewritten the code a bit to make it clearer but the idea is the same. The only big difference is that we are just getting the position of the mouse once clicked and give this point to two methods drag_paper and draw_paper.   func _on_Paper_gui_input(event): \t# Check if we pressed a mouse button \tif event is InputEventMouseButton: \t\t# Check if we pressed left mouse button \t\tif event.button_index == BUTTON_LEFT and event.pressed: \t\t\tvar point : Vector2 = self.get_global_mouse_position() # Get global mouse position \t\t\t# Call methods \t\t\tself.drag_paper(point) \t\t\tself.draw_paper(point) \t\telse: \t\t\t# Else set dragging and drawing false \t\t\tself.dragging = false \t\t\tself.drawing = false \t# Check if we moved the mouse while we drag the paper \tif event is InputEventMouseMotion and drag_position != Vector2.ZERO and self.dragging: \t\t# Set new position \t\tself.rect_global_position = self.get_global_mouse_position() - self.drag_position   Drag &amp; Draw   In essence these methods only check if we are inside the areas and set the boolean data types dragging and drawing. The method drag_paper does also some fancy stuff by updating the drag_position.   # Drag Method which checks if we are dragging the paper func drag_paper(point : Vector2) -&gt; void: \tself.dragging = is_point_in_area(point, drag_area_name) # Check if mouse is in drag area \tif self.dragging: \t\tInput.set_custom_mouse_cursor(drag_mouse) # Set mosue \t\tself.drag_position = self.get_global_mouse_position() - self.rect_global_position # Update drag position \telse: \t\tself.drag_position = Vector2.ZERO # Set drag position to zero vector  # Draw Method which checks if we are drawing on the paper  func draw_paper(point : Vector2) -&gt; void: \tself.drawing = is_point_in_area(point, draw_area_name) # Check if mouse is in draw area   Conclusion   That’s it! If you followed this tutorial correctly, you should be able to drag a paper and also draw on it. Based on this you can expand this mechanic for all kinds of application. I hope you enjoyed it!   I’m making a little game based on this mechanic, I’ll post other tutorials where we expand this idea a bit further. So stay tuned! :)   Download    You can find the the source code for this tutorial and all previouse and upcoming tutorials here.  ","categories": ["Tutorials"],
        "tags": ["Godot","Tutorial","Taikun"],
        "url": "http://localhost:4000/tutorials/godot-tutorial-2/",
        "teaser": null
      }]
